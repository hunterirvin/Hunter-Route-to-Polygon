
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Zone Widget</title>
<link rel="preconnect" href="https://unpkg.com" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
<style>
:root{ --bg:#0c0f14; --panel:#121722; --text:#e6e9ef; --muted:#aab0bb; --accent:#5ac8fa; --danger:#ff4d4f; --border:#1f2633; }
*{box-sizing:border-box}
html,body{height:100%;}
body{margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
.app{display:grid;grid-template-columns:360px 1fr;height:100vh}
.sidebar{background:var(--panel);border-right:1px solid var(--border);display:flex;flex-direction:column}
.header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:10px}
.header h1{font-size:16px;margin:0}
.theme{margin-left:auto;display:flex;gap:8px;align-items:center}
.theme label{font-size:12px;color:var(--muted)}
.main{position:relative}
#map{position:absolute;inset:0}
.section{padding:12px 16px;border-bottom:1px solid var(--border)}
.label{display:block;font-weight:600;margin-bottom:6px}
.small{font-size:12px;color:var(--muted)}
.mode-row{display:flex;gap:6px}
.mode-row label{display:block;padding:8px 10px;background:#0f1522;border:1px solid var(--border);border-radius:6px;text-align:center;cursor:pointer;color:var(--muted)}
.mode-row input{display:none}
.mode-row input:checked+label{background:#141b2b;color:var(--text);border-color:#2a3550}
#workflowPanels .panel{display:none;margin-top:10px}
#workflowPanels .panel.active{display:block}
.row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
input[type=text],input[type=number],select{background:#0b111b;color:var(--text);border:1px solid var(--border);border-radius:6px;padding:8px 10px}
input[type=number]{width:90px}
button{background:#1b2a44;color:var(--text);border:1px solid #294166;border-radius:6px;padding:8px 12px;cursor:pointer}
button.primary{background:#214d7a;border-color:#2c6fb0}
button:disabled{opacity:.5;cursor:not-allowed}
button.clear{background:#2a0f14;border-color:#4a1e26;color:#ffb3b3}
.code{background:#0a0f19;border:1px solid var(--border);border-radius:6px;padding:8px;color:#cde;white-space:pre-wrap;max-height:220px;overflow:auto}
.details{background:#0f1522;border:1px solid var(--border);border-radius:8px;padding:10px}
.manual-header{display:flex;align-items:center;justify-content:space-between;gap:12px}
.manual-note{font-weight:700}
.buffer-row{display:flex;align-items:center;gap:8px;flex-wrap:nowrap}
.footer{padding:10px 16px;color:var(--muted);font-size:12px}
.leaflet-control-container .leaflet-top.leaflet-left{margin-top:60px}
</style>
</head>
<body>
<div class="app">
  <aside class="sidebar">
    <div class="header">
      <h1>Zone Widget</h1>
      <div class="theme">
        <label>Map</label>
        <select id="mapTheme"><option value="dark" selected>Dark</option><option value="light">Light</option><option value="hc">High Contrast (B/W)</option></select>
      </div>
    </div>

    <div class="section">
      <div class="label">Input Mode</div>
      <div class="mode-row" id="modeRow">
        <input type="radio" id="mode-url" name="workflow" value="url"><label for="mode-url">Google Maps URL</label>
        <input type="radio" id="mode-manual" name="workflow" value="manual" checked><label for="mode-manual">Create Route Manually</label>
        <input type="radio" id="mode-regions" name="workflow" value="regions"><label for="mode-regions">Regions</label>
      </div>
    </div>

    <div class="section" id="workflowPanels">
      <div id="panel-url" class="panel">
        <div class="label">Google Maps Directions URL</div>
        <div class="row"><input id="urlInput" type="text" placeholder="Paste a Google Maps directions URL..." style="flex:1"><button id="parseUrlBtn">Parse URL</button></div>
        <div class="small">Short links supported; if a link fails due to CORS, open it once and paste the expanded URL.</div>
        <hr>
        <div class="small">Order matters: top is origin; bottom is destination. Drag pins on the map to adjust locations.</div>
      </div>

      <div id="panel-manual" class="panel active">
        <div class="manual-header"><div class="manual-note">Clicks on the map automatically add the next stop.</div><button id="clearManualBtn" class="clear">Clear</button></div>
        <div class="small">Max 10 stops. Drag pins on the map to adjust locations.</div>
      </div>

      <div id="panel-regions" class="panel">
        <div class="row"><label><input type="radio" name="regionMode" value="find" checked> Find Region</label><label><input type="radio" name="regionMode" value="draw"> Draw Region</label></div>
        <div id="region-find">
          <label class="label">Find Region by Name or ZIP (US)</label>
          <div class="row"><input id="regionQuery" list="region-suggest" type="text" placeholder="e.g., San Francisco, CA or 94103" style="flex:1"><datalist id="region-suggest"></datalist><button id="findRegionBtn">Find Region</button><button id="clearRegionBtn" class="clear">Clear Region</button></div>
          <div class="small">Tip: Start typing to see suggestions. Select a suggestion or press Enter to search.</div>
        </div>
        <div id="region-draw" style="display:none">
          <div class="small"><b>Drawing mode</b> is active. Click on the map to add vertices; click the first point to finish. Use <b>Clear Region</b> to remove.</div>
          <div class="row" style="margin-top:6px"><button id="clearDrawnBtn" class="clear">Clear Region</button></div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="label">Buffer Radius</div>
      <div class="buffer-row"><label class="label" for="bufferFeet" style="margin:0">Buffer (ft)</label><input id="bufferFeet" type="number" min="0" step="1" value="100"><button id="runBufferBtn" class="primary">Buffer</button></div>
      <details class="details" id="advBufferDetails"><summary>Advanced buffering</summary>
        <div class="row" style="margin-top:8px"><label class="label" for="arcSteps">Arc smoothness (steps)</label><input id="arcSteps" type="number" min="4" step="1" value="5"></div>
        <div class="row"><label class="label" for="simplifyTol">Simplify tolerance (meters)</label><input id="simplifyTol" type="number" min="0" step="0.5" value="10"></div>
        <div class="small">Higher arc smoothness creates smoother corners but increases vertices. Simplify removes small wiggles using the given meter tolerance (applied after buffering). Coordinates are rounded to <b>4 decimals</b>.</div>
      </details>
      <div id="working" class="small" style="display:none;margin-top:6px">⏳ Working... Please wait.</div>
    </div>

    <div class="section">
      <div class="label">Output</div>
      <div class="row"><label><input type="radio" name="fmt" value="wkt" checked> WKT</label><label><input type="radio" name="fmt" value="geojson"> GeoJSON</label><label><input type="radio" name="fmt" value="kml"> KML</label><label><input type="radio" name="fmt" value="shp"> Shapefile (.zip)</label></div>
      <div class="label" style="margin-top:8px">Preview (read-only)</div>
      <div id="preview" class="code" aria-live="polite"></div>
      <div class="row" style="margin-top:8px"><button id="downloadBtn">Download</button></div>
      <div class="small" style="margin-top:10px">• Switching between workflows (URL / Manual / Regions) clears the map layers. • Manual mode: click to add stops, drag pins to adjust. • Regions: search by name/ZIP or draw. • Output: choose a geometry & format to preview and download.</div>
    </div>

    <div class="footer">Zone Widget • v2025.10 • Hunter Irvin</div>
  </aside>
  <main class="main"><div id="map"></div></main>
</div>

<!-- Core libs -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<!-- Resilient loaders for optional deps (shp-write, terraformer/WKT, tokml) -->
<script>
async function loadScriptSequential(urls){
  for (const url of urls){
    try{
      await new Promise((resolve,reject)=>{ const s=document.createElement('script'); s.src=url; s.async=true; s.crossOrigin='anonymous'; s.onload=()=>resolve(); s.onerror=()=>reject(); document.head.appendChild(s);});
      return true;
    }catch(e){}
  }
  return false;
}
async function ensureShpWrite(){
  if (window.shpwrite) return true;
  const ok = await loadScriptSequential([
    'https://cdn.jsdelivr.net/npm/@mapbox/shp-write@0.4.3/dist/shpwrite.js',
    'https://unpkg.com/@mapbox/shp-write@0.4.3/dist/shpwrite.js',
    'https://cdn.jsdelivr.net/npm/@mapbox/shp-write@latest/dist/shpwrite.js',
    'https://unpkg.com/@mapbox/shp-write@latest/dist/shpwrite.js',
    'https://cdn.jsdelivr.net/npm/@mapbox/shp-write@0.3.2/dist/shpwrite.js',
    'https://unpkg.com/@mapbox/shp-write@0.3.2/dist/shpwrite.js',
    'https://cdn.jsdelivr.net/npm/@nickrsan/shp-write@0.3.7/dist/shpwrite.js',
    'https://unpkg.com/@nickrsan/shp-write@0.3.7/dist/shpwrite.js',
    'https://cdn.jsdelivr.net/npm/@simwrapper/shp-write@0.3.3/dist/shpwrite.js',
    'https://unpkg.com/@simwrapper/shp-write@0.3.3/dist/shpwrite.js',
    'https://cdn.jsdelivr.net/npm/@mapbox/shp-write@0.4.3/shpwrite.js',
    'https://unpkg.com/@mapbox/shp-write@0.4.3/shpwrite.js'
  ]);
  return ok && !!window.shpwrite;
}
async function ensureTerraformerWKT(){
  if (window.Terraformer && window.Terraformer.WKT) return true;
  const ok1 = await loadScriptSequential([
    'https://cdn.jsdelivr.net/npm/terraformer@1.0.12/terraformer.min.js',
    'https://unpkg.com/terraformer@1.0.12/terraformer.min.js',
    'https://cdn.jsdelivr.net/npm/terraformer@1.0.12/terraformer.js',
    'https://unpkg.com/terraformer@1.0.12/terraformer.js'
  ]);
  const ok2 = await loadScriptSequential([
    'https://cdn.jsdelivr.net/npm/terraformer-wkt-parser@1.2.1/terraformer-wkt-parser.min.js',
    'https://unpkg.com/terraformer-wkt-parser@1.2.1/terraformer-wkt-parser.min.js',
    'https://cdn.jsdelivr.net/npm/terraformer-wkt-parser@1.2.1/terraformer-wkt-parser.js',
    'https://unpkg.com/terraformer-wkt-parser@1.2.1/terraformer-wkt-parser.js'
  ]);
  return (ok1 && ok2 && window.Terraformer && window.Terraformer.WKT);
}
async function ensureToKml(){
  if (window.tokml) return true;
  const ok = await loadScriptSequential([
    'https://cdn.jsdelivr.net/npm/tokml@0.4.0/tokml.js',
    'https://unpkg.com/tokml@0.4.0/tokml.js'
  ]);
  return ok && !!window.tokml;
}
</script>

<script>
// Map setup
const map = L.map('map', {zoomControl:true}).setView([37.7749,-122.4194], 12);

// **Open & free dark raster** from CARTO basemaps: Dark Matter (no auth required) 
// Docs & styles: https://github.com/CartoDB/basemap-styles
// Provider catalog: https://leaflet-extras.github.io/leaflet-providers/preview/
const darkBase = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
  attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">OpenStreetMap</a> contributors, © <a href="https://carto.com/attributions" target="_blank" rel="noopener">CARTO</a>',
  subdomains: 'abcd',
  maxZoom: 20
});
const darkLabels = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', {
  attribution: '', subdomains: 'abcd', maxZoom: 20, opacity: 0.95
});

const dark = L.layerGroup([darkBase, darkLabels]);

// Light: OSM Standard (open & free)
const light = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">OpenStreetMap</a> contributors',
  maxZoom: 19
});

// Optional high-contrast B/W using CARTO Toner-like (Toner is legacy) — use CARTO dark without labels + labels only
const highContrast = L.layerGroup([
  L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', { subdomains: 'abcd', maxZoom: 20 }),
  L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', { subdomains: 'abcd', maxZoom: 20, opacity: 1 })
]);

// default add dark
dark.addTo(map);

const drawn = new L.FeatureGroup(); map.addLayer(drawn);
const drawControl = new L.Control.Draw({ edit:{ featureGroup:drawn, edit:true, remove:true }, draw:{ polyline:false, rectangle:false, circle:false, marker:false, circlemarker:false, polygon:{showArea:true} } });
let drawEnabled=false; let drawHandler=null;

// State
let workflow='manual';
let regionMode='find';
let manualStops=[]; let manualRoute=null; let urlRoute=null; let regionPoly=null; let bufferPoly=null;

function clearAll(){ manualStops.forEach(m=>map.removeLayer(m)); manualStops=[]; if(manualRoute){map.removeLayer(manualRoute);manualRoute=null;} if(urlRoute){map.removeLayer(urlRoute);urlRoute=null;} if(regionPoly){map.removeLayer(regionPoly);regionPoly=null;} if(bufferPoly){map.removeLayer(bufferPoly);bufferPoly=null;} drawn.clearLayers(); updatePreview(); }
function fitTo(layer){ try{ map.fitBounds(layer.getBounds(), {padding:[20,20]}); }catch(e){} }
function activeGeometryGeoJSON(){ if(bufferPoly) return bufferPoly.toGeoJSON(); if(regionPoly) return regionPoly.toGeoJSON(); if(workflow==='manual'&&manualRoute) return manualRoute.toGeoJSON(); if(workflow==='url'&&urlRoute) return urlRoute.toGeoJSON(); return null; }

function asFeatureCollection(gj){ if(!gj) return null; if(gj.type==='FeatureCollection') return gj; if(gj.type==='Feature') return {type:'FeatureCollection',features:[gj]}; return {type:'FeatureCollection',features:[{type:'Feature',properties:{},geometry:gj}]}; }
function wktFrom(gj){ if(!gj) return ''; if (gj.type==='FeatureCollection') return gj.features.map(f=>Terraformer.WKT.convert(f.geometry)).join('\n'); if(gj.type==='Feature') return Terraformer.WKT.convert(gj.geometry); return Terraformer.WKT.convert(gj); }

async function updatePreview(){
  const fmt=document.querySelector('input[name="fmt"]:checked').value; const gj=activeGeometryGeoJSON(); const prev=document.getElementById('preview'); if(!gj){ prev.textContent='—'; return; }
  try{
    if(fmt==='geojson'){ prev.textContent=JSON.stringify(gj,null,2); }
    else if(fmt==='wkt'){ const ok=await ensureTerraformerWKT(); if(!ok){ prev.textContent='WKT preview unavailable (Terraformer not loaded).'; return; } prev.textContent=wktFrom(gj); }
    else if(fmt==='kml'){ const ok=await ensureToKml(); if(!ok){ prev.textContent='KML preview unavailable (tokml not loaded).'; return; } prev.textContent=tokml(asFeatureCollection(gj)); }
    else if(fmt==='shp'){ prev.textContent='Shapefile will be downloaded as a .zip when you click Download.' }
  }catch(e){ prev.textContent='Error generating preview: '+e.message; }
}

const PRECISION_FIXED = 4;
function roundCoords(gj){ function r(n){return +n.toFixed(PRECISION_FIXED);} function rc(c){ if(typeof c[0]==='number') return [r(c[0]),r(c[1])]; return c.map(rc);} const out=JSON.parse(JSON.stringify(gj)); if(out.type==='Feature') out.geometry.coordinates=rc(out.geometry.coordinates); else if(out.type==='FeatureCollection') out.features=out.features.map(f=>{f.geometry.coordinates=rc(f.geometry.coordinates); return f}); else out.coordinates=rc(out.coordinates); return out; }
function toFeatureOrCollection(gj){ if(!gj) return null; if(gj.type==='Feature'||gj.type==='FeatureCollection') return gj; if(gj.type&&gj.coordinates) return {type:'Feature',properties:{},geometry:gj}; if(gj.geometry) return {type:'Feature',properties:gj.properties||{},geometry:gj.geometry}; return null; }

function setActivePanel(){ document.querySelectorAll('#workflowPanels .panel').forEach(p=>p.classList.remove('active')); const id=(workflow==='url')?'panel-url':(workflow==='manual')?'panel-manual':'panel-regions'; document.getElementById(id).classList.add('active'); }

function startPolygonDraw(){ if (!drawEnabled){ map.addControl(drawControl); drawEnabled=true; } if (drawHandler) { try{ drawHandler.disable(); }catch(e){} } drawHandler = new L.Draw.Polygon(map, drawControl.options.draw.polygon); drawHandler.enable(); }
function stopPolygonDraw(){ if(drawHandler){ try{ drawHandler.disable(); }catch(e){} drawHandler=null; } }

document.getElementById('modeRow').addEventListener('change',e=>{ if(e.target&&e.target.name==='workflow'){ workflow=e.target.value; clearAll(); setActivePanel(); if(workflow==='regions'&&regionMode==='draw'){ startPolygonDraw(); } else { stopPolygonDraw(); if(drawEnabled){ map.removeControl(drawControl); drawEnabled=false; } } }});

// Theme toggle among free/open raster layers
const themeSel = document.getElementById('mapTheme');
let currentBase = dark; // default
function setBase(layer){ if(currentBase){ map.removeLayer(currentBase); } currentBase = layer; layer.addTo(map); }

themeSel.addEventListener('change', e=>{
  const v=e.target.value;
  if (v==='dark') setBase(dark);
  else if (v==='light') setBase(light);
  else if (v==='hc') setBase(highContrast);
});

// OSRM routing
function coordsToOSRMString(latlngs){ return latlngs.map(ll=>`${ll.lng.toFixed(6)},${ll.lat.toFixed(6)}`).join(';'); }
async function fetchOSRMRoute(latlngs){ if(latlngs.length<2) throw new Error('Need at least 2 waypoints'); const coords=coordsToOSRMString(latlngs); const url=`https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson&steps=false&alternatives=false`; const res=await fetch(url,{headers:{'Accept':'application/json'}}); if(!res.ok) throw new Error('OSRM network error'); const data=await res.json(); if(data.code!=='Ok'||!data.routes||!data.routes[0]) throw new Error('OSRM returned no route'); return data.routes[0].geometry; }
let routeTimer=null; function setWorking(v){ document.getElementById('working').style.display = v?'block':'none'; }
async function buildManualRoute(){ if(manualRoute){map.removeLayer(manualRoute);manualRoute=null;} const pts=manualStops.map(m=>m.getLatLng()); if(pts.length<2){ updatePreview(); return; } setWorking(true); try{ const geom=await fetchOSRMRoute(pts); manualRoute=L.geoJSON({type:'Feature',properties:{},geometry:geom},{style:{color:'#5ac8fa',weight:3}}).addTo(map); fitTo(manualRoute);} catch(e){ console.warn(e); manualRoute=L.polyline(pts,{color:'#5ac8fa'}).addTo(map);} finally{ setWorking(false); updatePreview(); } }
async function buildUrlRoute(latlngs){ if(urlRoute){map.removeLayer(urlRoute);urlRoute=null;} if(!latlngs||latlngs.length<2) return; setWorking(true); try{ const geom=await fetchOSRMRoute(latlngs); urlRoute=L.geoJSON({type:'Feature',properties:{},geometry:geom},{style:{color:'#5ac8fa',weight:3}}).addTo(map); fitTo(urlRoute);} catch(e){ console.warn(e); urlRoute=L.polyline(latlngs,{color:'#5ac8fa'}).addTo(map);} finally{ setWorking(false); updatePreview(); } }

// Manual
map.on('click',e=>{ if(workflow!=='manual') return; if(manualStops.length>=10){ alert('Max 10 stops'); return; } const idx=manualStops.length+1; const m=L.marker(e.latlng,{draggable:true,title:'Stop '+idx}).addTo(map); m.bindTooltip(String(idx),{permanent:true,direction:'top',className:'stop-label'}).openTooltip(); m.on('dragend',()=>{clearTimeout(routeTimer); routeTimer=setTimeout(buildManualRoute,250);}); manualStops.push(m); clearTimeout(routeTimer); routeTimer=setTimeout(buildManualRoute,150); });

document.getElementById('clearManualBtn').addEventListener('click',()=>{ manualStops.forEach(m=>map.removeLayer(m)); manualStops=[]; if(manualRoute){map.removeLayer(manualRoute);manualRoute=null;} if(bufferPoly){map.removeLayer(bufferPoly);bufferPoly=null;} updatePreview(); });

// URL workflow
function parseGoogleMapsURL(url){ try{ const u=new URL(url); const parts=u.pathname.split('/').filter(Boolean); const coords=[]; if(parts[0]==='maps'&&parts[1]==='dir'){ for(let i=2;i<parts.length;i++){ const seg=decodeURIComponent(parts[i]); if(/^\-?\d+\.\d+,\-?\d+\.\d+$/.test(seg)){ const [lat,lng]=seg.split(',').map(Number); coords.push(L.latLng(lat,lng)); } } } if(coords.length<2&&u.href.includes('@')){ const after=u.href.split('@')[1].split(','); if(after.length>=2) coords.push(L.latLng(parseFloat(after[0]),parseFloat(after[1]))); } return coords; }catch(e){ return []; } }

document.getElementById('parseUrlBtn').addEventListener('click',()=>{ const txt=document.getElementById('urlInput').value.trim(); if(!txt) return; const pts=parseGoogleMapsURL(txt); if(pts.length<2){ alert('Could not find at least two coordinates in the URL. Paste a full /dir/ URL.'); return; } buildUrlRoute(pts); });

// Regions — suggestions & auto-find on selection/enter
const regionQuery=document.getElementById('regionQuery'); let suggestTimer=null; async function suggestRegions(q){ const url=`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&addressdetails=0&limit=5`; const res=await fetch(url,{headers:{'Accept':'application/json'}}); if(!res.ok) return []; return await res.json(); }
regionQuery.addEventListener('input',()=>{ const q=regionQuery.value.trim(); clearTimeout(suggestTimer); if(q.length<3) return; suggestTimer=setTimeout(async()=>{ try{ const list=await suggestRegions(q); const dl=document.getElementById('region-suggest'); dl.innerHTML=''; list.forEach(item=>{ const opt=document.createElement('option'); opt.value=item.display_name; dl.appendChild(opt); }); }catch(e){} },300); });

async function geocodePolygon(query){ const url=`https://nominatim.openstreetmap.org/search?format=json&polygon_geojson=1&q=${encodeURIComponent(query)}`; const res=await fetch(url,{headers:{'Accept':'application/json'}}); if(!res.ok) throw new Error('Geocoder error'); const arr=await res.json(); for (const it of arr){ if (it.geojson && (it.geojson.type==='Polygon' || it.geojson.type==='MultiPolygon')) return it; } throw new Error('No polygon found.'); }

async function doFindRegion(){
  const q = regionQuery.value.trim(); if (!q) return;
  try{
    const it = await geocodePolygon(q);
    if (regionPoly) { map.removeLayer(regionPoly); regionPoly=null; }
    if (bufferPoly) { map.removeLayer(bufferPoly); bufferPoly=null; }
    const gj = it.geojson;
    regionPoly = L.geoJSON(gj, {style:{color:'#9b87f5', weight:2, fillOpacity:0.15}}).addTo(map);
    fitTo(regionPoly);
    updatePreview();
  }catch(e){ alert(e.message); }
}

document.getElementById('findRegionBtn').addEventListener('click', doFindRegion);
regionQuery.addEventListener('change', ()=>{ if (regionQuery.value.trim().length >= 3) doFindRegion(); });
regionQuery.addEventListener('keydown', (e)=>{ if (e.key==='Enter'){ e.preventDefault(); if (regionQuery.value.trim().length >= 3) doFindRegion(); } });

document.getElementById('clearRegionBtn').addEventListener('click',()=>{ if(regionPoly){map.removeLayer(regionPoly);regionPoly=null;} if(bufferPoly){map.removeLayer(bufferPoly);bufferPoly=null;} updatePreview(); });
Array.from(document.getElementsByName('regionMode')).forEach(r=>r.addEventListener('change',e=>{ regionMode=e.target.value; document.getElementById('region-find').style.display=regionMode==='find'?'':'none'; document.getElementById('region-draw').style.display=regionMode==='draw'?'':'none'; if(regionMode==='draw'){ startPolygonDraw(); } else { stopPolygonDraw(); if(drawEnabled){ map.removeControl(drawControl); drawEnabled=false; } } }));

map.on(L.Draw.Event.CREATED, e=>{ if(workflow!=='regions' || regionMode!=='draw') return; drawn.clearLayers(); drawn.addLayer(e.layer); if(regionPoly){map.removeLayer(regionPoly);regionPoly=null;} if(bufferPoly){map.removeLayer(bufferPoly);bufferPoly=null;} regionPoly=e.layer; stopPolygonDraw(); fitTo(regionPoly); updatePreview(); });

document.getElementById('clearDrawnBtn').addEventListener('click',()=>{ drawn.clearLayers(); if(regionPoly){map.removeLayer(regionPoly);regionPoly=null;} if(bufferPoly){map.removeLayer(bufferPoly);bufferPoly=null;} if (workflow==='regions' && regionMode==='draw') startPolygonDraw(); updatePreview(); });

// Buffering
function getMetersFromFeet(){ const ft=parseFloat(document.getElementById('bufferFeet').value||'0'); if(!isFinite(ft)||ft<0) return 0; return ft*0.3048; }
function getAdv(){ return { steps:Math.max(4,parseInt(document.getElementById('arcSteps').value||'5',10)), simplify:Math.max(0,parseFloat(document.getElementById('simplifyTol').value||'10')) }; }
async function runBuffer(){ const meters=getMetersFromFeet(); if(!meters){ alert('Enter a buffer greater than 0 feet.'); return; } const adv=getAdv(); const src=(regionPoly||(manualRoute||urlRoute)); if(!src){ alert('Add a route or region first.'); return; } setWorking(true); try{ const gjRaw=src.toGeoJSON(); const input=toFeatureOrCollection(gjRaw); if(!input) throw new Error('Invalid geometry'); const buffered=turf.buffer(input, meters, {units:'meters',steps:adv.steps}); let out=buffered; if(adv.simplify>0){ out=turf.simplify(out,{tolerance:adv.simplify/111320,highQuality:true}); } out=roundCoords(out); if(bufferPoly){map.removeLayer(bufferPoly);bufferPoly=null;} bufferPoly=L.geoJSON(out,{style:{color:'#34c759',weight:2,fillOpacity:0.18}}).addTo(map); fitTo(bufferPoly); updatePreview(); }catch(e){ alert('Buffer error: '+e.message);} finally{ setWorking(false);} }

document.getElementById('runBufferBtn').addEventListener('click', runBuffer);

// Output & download
Array.from(document.getElementsByName('fmt')).forEach(r=>r.addEventListener('change',()=>{ updatePreview(); }));
function currentFeature(){ const gj=activeGeometryGeoJSON(); if(!gj) return null; const input=toFeatureOrCollection(gj); if(!input) return null; if(input.type==='Feature') return input; if(input.type==='FeatureCollection') return input.features[0]; return null; }
function download(filename, content){ const blob=new Blob([content],{type:'application/octet-stream'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),2500); }
async function downloadShapefile(feature){ if(!feature||!feature.geometry){ alert('Nothing to download.'); return; } const coll={type:'FeatureCollection',features:[feature]}; if(!window.shpwrite){ const ok=await ensureShpWrite(); if(!ok){ alert('Unable to load Shapefile exporter.'); return; } } try{ let zipData=shpwrite.zip(coll,{file:'zone-widget'}); if(zipData&&typeof zipData.then==='function') zipData=await zipData; const blob=(zipData instanceof Blob)?zipData:new Blob([zipData],{type:'application/zip'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='zone-widget.zip'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),2500);}catch(e){ alert('Shapefile export failed: '+e.message);} }

document.getElementById('downloadBtn').addEventListener('click', async()=>{ const fmt=document.querySelector('input[name="fmt"]:checked').value; const f=currentFeature(); if(!f){ alert('Nothing to download.'); return; } if(fmt==='geojson'){ download('zone-widget.geojson', JSON.stringify({type:'FeatureCollection',features:[f]},null,2)); } else if(fmt==='wkt'){ const ok=await ensureTerraformerWKT(); if(!ok){ alert('Terraformer not available.'); return; } const txt=wktFrom(f); download('zone-widget.wkt', txt); } else if(fmt==='kml'){ const ok=await ensureToKml(); if(!ok){ alert('tokml not available.'); return; } const kml=tokml(asFeatureCollection(f)); download('zone-widget.kml', kml); } else if(fmt==='shp'){ await downloadShapefile(f); } });

// Init
(function init(){ document.getElementById('mode-manual').checked=true; setActivePanel(); updatePreview(); })();
</script>
</body>
</html>
