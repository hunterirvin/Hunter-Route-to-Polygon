<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Route Buffer Tool — Web</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet CSS/JS (official CDN with SRI; required paths, not the CDN root) -->
  https://unpkg.com/leaflet@1.9.4/dist/leaflet.css
  https://unpkg.com/leaflet@1.9.4/dist/leaflet.js</script>

  <!-- Turf v7 (buffering, etc.) -->
  https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js</script>

  <!-- Terraformer WKT (UMD build exposes global 'Terraformer') -->
  https://unpkg.com/@terraformer/wkt@2.2.1/dist/terraformer-wkt.umd.min.js</script>

  <style>
    :root { --pad: 12px; --accent:#0066ff }
    body { margin: 0; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header, .panel { padding: var(--pad); }
    header { background:#0b1220; color:#fff; }
    h1 { font-size:16px; margin:0 }
    #map { height: 62vh; }
    label { display:block; margin:.4rem 0 .25rem; font-weight:600 }
    input[type="text"], input[type="number"] { width:100%; padding:.5rem; border:1px solid #ccc; border-radius:6px }
    .row { display:grid; grid-template-columns: 1fr 160px; gap:12px; align-items:end }
    button { padding:.6rem 1rem; background:var(--accent); color:#fff; border:0; border-radius:6px; font-weight:600; cursor:pointer }
    button:disabled { opacity:.6; cursor:default }
    textarea { width:100%; height:9rem; padding:.5rem; border:1px solid #ccc; border-radius:6px; font-family: ui-monospace, SFMono-Regular, Consolas, monospace }
    .muted { color:#555; font-size:12px }
    .status { margin:.25rem 0 .75rem; min-height:1.25rem }
    .error { color:#b00020 }
    .hint { color:#333; font-size:12px; margin-top:.2rem }
    .badgelike { display:inline-block; padding:.1rem .5rem; border-radius:999px; background:#eef; color:#223; font-size:12px; margin-left:.25rem }
    .footer { padding: var(--pad); font-size:12px; color:#555 }
    .footer a { color: #333 }
    .diag { font-family: ui-monospace, SFMono-Regular, Consolas, monospace; word-break: break-all; }
  </style>
</head>
<body>
  <header>
    <h1>Route Buffer Tool — Web <span class="badgelike">no install</span></h1>
  </header>

  <div class="panel">
    <label for="gmapsUrl">Google Maps directions URL</label>
    <input id="gmapsUrl" type="text" placeholder="Paste a link like https://www.google.com/maps/dir/37.7749,-122.4194/37.784,-122.407 ..." />
    <div class="hint">
      Tip: directions links with <code>/dir/lat,lng/lat,lng</code> work best; we extract those coordinates per Google’s Maps URLs behavior. 
    </div>

    <div class="row" style="margin-top:.75rem">
      <div>
        <label for="bufferMeters">Buffer distance (meters)</label>
        <input id="bufferMeters" type="number" min="1" step="1" value="50" />
        <div class="hint">e.g., 10, 25, 50, 100…</div>
      </div>
      <div>
        <button id="runBtn">Generate buffer</button>
      </div>
    </div>

    <div class="status" id="status"></div>
    <div id="map"></div>

    <label for="wktOut" style="margin-top:1rem">Buffered polygon (WKT)</label>
    <textarea id="wktOut" readonly placeholder="Will appear here…"></textarea>

    <div class="hint" style="margin-top:.5rem">
      Routing: OSRM demo server (for light use only). Tiles: © OpenStreetMap contributors. See “Notes & limits” below. 
    </div>
  </div>

  <div class="footer">
    <div><strong>Diagnostics</strong>: <span id="diag" class="diag muted"></span></div>
    Notes & limits: The OSRM demo server is for testing, not production (may rate‑limit or be down). Switch <code>OSRM_BASE_URL</code> to your own OSRM server (Docker) or a paid service for reliability. Respect the OpenStreetMap tile usage policy or bring your own tiles. 
  </div>

  <script>
    // === Config you can tweak later ===
    const OSRM_BASE_URL = 'https://router.project-osrm.org'; // swap to your server if needed
    const PROFILE = 'driving'; // 'driving' | 'cycling' | 'walking' if your server supports it

    // === Leaflet map ===
    const map = L.map('map').setView([37.773972, -122.431297], 12);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; https://www.openstreetmap.org/copyrightOpenStreetMap</a>',
      maxZoom: 19
    }).addTo(map);

    const routeLayer = L.geoJSON(null, { style: { color: '#0066ff', weight: 4 } }).addTo(map);
    const bufferLayer = L.geoJSON(null, { style: { color: '#ff008a', weight: 2, fillOpacity: 0.25 } }).addTo(map);

    const $ = (id) => document.getElementById(id);
    const setStatus = (msg, isError=false) => {
      const el = $('status');
      el.textContent = msg || '';
      el.className = 'status' + (isError ? ' error' : '');
    };

    // Extract lat,lng pairs from a Google Maps URL
    function parseLatLngsFromGMaps(url) {
      const coords = [];

      try {
        const u = new URL(url);
        // Pattern 1: /maps/dir/<part1>/<part2>/... where parts may be "lat,lng"
        const dirIdx = u.pathname.indexOf('/dir/');
        if (dirIdx !== -1) {
          const tail = decodeURIComponent(u.pathname.slice(dirIdx + 5)); // after "/dir/"
          for (const segRaw of tail.split('/')) {
            const seg = segRaw.trim();
            if (/^-?\d+(\.\d+)?,-?\d+(\.\d+)?$/.test(seg)) {
              const [lat, lng] = seg.split(',').map(Number);
              coords.push([lat, lng]);
            }
          }
        }

        // Pattern 2: @lat,lng in URL
        const atMatch = url.match(/@(-?\d+\.?\d*),(-?\d+\.?\d*)/);
        if (atMatch) {
          coords.push([parseFloat(atMatch[1]), parseFloat(atMatch[2])]);
        }

        // Pattern 3: query params q= or query= or origin/destination as lat,lng
        const tryKeys = ['q','query','origin','destination','waypoints'];
        for (const k of tryKeys) {
          const v = u.searchParams.get(k);
          if (v && /^-?\d+(\.\d+)?,-?\d+(\.\d+)?$/.test(v)) {
            const [lat, lng] = v.split(',').map(Number);
            coords.push([lat, lng]);
          }
        }

      } catch (e) {
        // ignore URL parse errors
      }

      // De-dup while preserving order
      const seen = new Set();
      const uniq = [];
      for (const [lat,lng] of coords) {
        const key = lat.toFixed(7)+','+lng.toFixed(7);
        if (!seen.has(key)) { seen.add(key); uniq.push([lat,lng]); }
      }
      return uniq;
    }

    async function run() {
      setStatus('');
      routeLayer.clearLayers();
      bufferLayer.clearLayers();
      $('wktOut').value = '';
      $('diag').textContent = '';

      const url = $('gmapsUrl').value.trim();
      const meters = parseFloat($('bufferMeters').value);
      if (!url) return setStatus('Please paste a Google Maps directions URL.', true);
      if (!(meters > 0)) return setStatus('Enter a positive buffer distance (meters).', true);

      const latlngs = parseLatLngsFromGMaps(url);
      if (latlngs.length < 2) {
        return setStatus('Could not find enough coordinates. Please use a URL with explicit lat,lng for origin and destination (e.g., /dir/lat,lng/lat,lng).', true);
      }

      // Build OSRM coordinates string "lon,lat;lon,lat;..."
      const osrmCoords = latlngs.map(([lat,lng]) => `${lng},${lat}`).join(';');
      const routeUrl = `${OSRM_BASE_URL}/route/v1/${PROFILE}/${osrmCoords}?overview=full&geometries=geojson&steps=false&alternatives=false&annotations=false&continue_straight=true`;
      $('diag').textContent = routeUrl;

      setStatus('Requesting route…');

      let data;
      try {
        const resp = await fetch(routeUrl);
        if (!resp.ok) {
          throw new Error(`HTTP ${resp.status}`);
        }
        data = await resp.json();
      } catch (err) {
        return setStatus(`Routing request failed. ${err.message}. If this persists, the public demo may be rate-limiting or blocking cross-origin requests—try again or point to your own OSRM server.`, true);
      }

      if (!data || data.code !== 'Ok' || !data.routes?.length) {
        return setStatus(`Routing API error: ${data?.code || 'Unknown error'}`, true);
      }

      const routeGeom = data.routes[0].geometry; // GeoJSON LineString
      const routeFeat = { type: 'Feature', properties: {}, geometry: routeGeom };
      routeLayer.addData(routeFeat);

      setStatus('Buffering…');
      // Turf buffer expects distance + units; docs recommend kilometers, so convert meters -> km.
      const buffered = turf.buffer(routeFeat, meters / 1000, { units: 'kilometers' });
      bufferLayer.addData(buffered);

      // Zoom to buffer or the route
      const bounds = bufferLayer.getBounds().isValid() ? bufferLayer.getBounds() : routeLayer.getBounds();
      if (bounds.isValid()) map.fitBounds(bounds, { padding: [20,20] });

      // WKT output (geometry only)
      const wkt = Terraformer.geojsonToWKT(buffered.geometry);
      $('wktOut').value = wkt;

      setStatus('Done.');
    }

    document.getElementById('runBtn').addEventListener('click', run);
  </script>
</body>
</html>
